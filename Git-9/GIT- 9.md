==========
https://githowto.com/ru/removing_commits_from_a_branch
==БАЗИСНОЕ

git init FolderName
git status //st
git add .        //добавляет только вновь созданные и измененные файлы, а удаленные не добавляет
git add -A       //добавляет все файлы (вновь созданные, измененные и удаленные)
git add -p       //показать изменённые файлы по очереди с указанием их изменений и вопросом об отслеживании/индексировании

git commit -m "Пояснения" -a   //git ci -m "Пояснения" -a

git add file.js.
git commit --amend -m "Новые пояснения" -a   //перезаписать в предыдущий коммит
git commit --amend --no-edit                 //перезаписать в предыдущий коммит, не создавая сообщения

git reset HEAD~2   //удалить последние 2 коммита. Текущий новый код в редакторе остается целым, но его надо ADD и commit. 
git reset --soft HEAD^

git rebase -i HEAD~4 //обработать(сжать) 4 последних коммита. См ниже rebase.




=======================
==УДАЛЕННЫЙ РЕПЕРТОРИУМ

//ПОЛУЧЕНИЕ
git clone https://gitlab.com/neurotrend/pyeye.git FolderName //это можно делать из безгитовой папки, далее зайти в скаченную папку (в ней будет git), делать правки, комитить и пушить обратно на удаленный реп. Склонируется только master (!).
git clone --single-branch -b borisenko https://gitlab.com/neuro/pye.git  //клон конкретной ветки
 
git remote -v      //проверка подключенности удаленного хранилища
git pull              //извлекает и сливает с текущей веткой локальной версиии
git pull --rebase

git pull origin branchName  //cтянуть определённую ветку branchName с удаленного репозитория origin
//по умолчанию git pull - это git pull origin master,
можно привязать текущую локальную ветку к какой-нибудь ветке (dev) удаленного реп-я (origin)
git branch -u origin/dev
а далее git pull без его расширений будет скачивать именно оттуда.

git pull аналогичен комбинации 2 команд:
git fetch origin && merge origin/dev


..
git fetch –all   //скачать с удаленного репа ВСЕ его ветки, а не только master-ветку
а далее
git pull origin dev



//PUSH_to
git remote add origin https://github.com/Vesna016/skills.git    \\плодключаемся к удаленному репу. Это только для push!
git push -u origin master                                       \\ origin- псевдоним, который мы ДАЛИ(!) ПРИНИМАЮЩЕМУ(!) репозиторию by командой выше.
                                                                \\ master - локальная ветка, в которую пушим.
Указанные команды нужно ввести только 1раз. После этого, чтобы запушить, нужно будет указывать только 
git push
git push -f origin new_branch

После создания в локальном реп-рии новой ветки dev_nick пушим ее, тоже создавая в Gitlab новую ветку
git push --set-upstream origin dev_nick
или тоже самое, но сокращенной командой,
git push -u origin dev_nick


=====
PUSH на удаленный реп

создаю свою ветку dev_nick_05 и кодю в ней
git co -b dev_nick_05 fd80930

пуш своей свежесозданной локальной ветки на dev-ветку удаленного реп-я:
git push --set-upstream origin dev_nick_05

а далее жму удаленном репе кнопку "Merge Request".

Если возник конфликт, то в лок репе перехожу на ветку dev
 git co dev
спулить обновления ветки dev с удаленного репа
 git pull
зайти на свою ветку обратно
 git co dev_nick_05
 git merge dev
(устраняю конфликты в ходе мержа)

Далее вновь запушить свой локальный реп на удаленный
 git push

Но повторно Merge Request создавать не надо, старый просто обновиться.
=====




==========
=====ВЕТВИ

//ВЕТВИ-НАЛИЧИЕ
git pull   //обновим локальную версию !!!
git br                    //какие ветки существуют ЛОКАЛЬНО
git branch –r             //какие ветки существуют удаленно    
git branch -a             // показать ВСЕ имеющиеся ветки (локальные и удаленного репа)

ls                                 //какие файлы на текущем коммите находяться
git branch name2 nameNewBr         //создание новой ветки, +oстаемся на прежней ветке.

git branch –m nameOldBr nameNewBr  //переименование ветки, находясь НА ИНОЙ ветке
git branch -m nameNewBr            //поменять имя ТЕКУЩЕЙ ветки

git branch –d name                 //удаление ветки
git branch -D name
push origin --delete my            //удаление ветки на УДАЛЕННОМ репертории


//ВЕТВИ-ПЕРЕКЛЮЧЕНИЕ
git checkout            //если переключаемся без указания имени- значит переключаемся на последний коммит
git checkout master     //= переход на самый свежий коммит ветки "master". Делать надо так!
git checkout we9055c .  //Точка (.) после имени ветки является обязательной. (?!)

git checkout -b nameNewBr             //создать новую ветку с текущего коммита и перейти на нее
git checkout -b nameNewBr we9055c     //создать новую ветку с we9055c-коммита и перейти на нее

Изменения в рабочей директории — как индексированные, так и неиндексированные, но незакоммеченные — пока не принадлежат ни одной ветке. 

//Переключение на ветки СКАЧЕННОГО репа.
git co remotes/origin/dev_nick  - wrong, будет переключение с detached_head, т.к. переключаемся НЕ на локальную ветку.
git co dev_nick                 - yes



//ПРОСМОТР ДЕРЕВА КОММИТОВ
git graph  (выйти: q)  //это alias для команды log --oneline --graph --decorate --all -M -C

git log --oneline --graph     //графически
git log --oneline --decorate  //список соммитов текущей ветки
git log --all -3 -p           //все данные, с указанием ДАТЫ и автора
 -(n) Показывает только последние n коммитов.
 -p   Показывает разницу для каждого коммита.
(выйти: q)

--author="Alex Kras" — выводит коммиты, сделанные конкретным человеком
--name-only — выводит только названия изменённых файлов
--oneline — выводит сокращённые данные коммита (в виде одной строки)
--graph — выводит дерево зависимостей для всех коммитов
--reverse — выводит коммиты в обратном хронологическом порядке (сначала старые)
--after — выводит коммиты, сделанные после определённой даты
--before — выводит коммиты, сделанные до определённой даты

git hist  // список всех последних хэшей(коммитов), где
git config --global alias.hist "log --pretty=format:'%h %ad | %s%d [%an]' --graph --date=short"




//MERGE ВЕТОК (всасывание и интеграция)
>>git co master
>>git merge br2               //текущая ветка master всасывает ветку br2 (br2 вливаем в текущую ветку)
git merge br2 --no-ff    // << ветка br2 сохранится обособленной, будет создан новый, объединяющий commit.
>>git branch -d br2           //удаление ветки br2

git merge current master  //не всасывание, а иньекция себя в master. marge current to master. Не сработало...

устраняем КОНФЛИКТ
git add ./src/CONFLICT_file_ONLY  //ONLY(!) CONFLICT_file
или
git add src/CONFLICT_file_ONLY  //ONLY(!) CONFLICT_file
git ci -m 'merge' -a

или прерываем продолжение мержа, не устраняя конфликт, с откатом до состояния №перед мержем"
git merge abort


# Вариант мержа №2 - БЕЗ переноса точек коммитов.
git checkout master
git merge --squash dev              <<<<<<<<<<<<<<<<<<<
git commit -m "Add new feature."    <<(!) НАДО(!) При squash-мерже - коммит не делается! Просто переноситься код, и все!


# Вариант мержа №3
git merge --no-commit br2
- Смержим, но комит автоматически не сделается. Нужно его сделать самому.    /врут/
- Точки коммитов, сделанные на ветке br2, не перенесутся. (!). It make scwach.


# В дереве коммитов метим рубежную точку.
$ git tag -a 1.2  \\ метим точку в тегом, который соответствует релизу.


//REBASE
//REBASE myself to ТОП ДРУГОЙ ВЕТКИ (инъекция себя на top другой ветки В РОЛИ ЕЕ ВЕТКИ + интеграция с последним коммитом этой ветки,причем исходная ветка удаляется).

git rebase master   //перемещаем начало текущей ветки на top master'a, интегрируя отличия, которые присутствуют с top'e master'ом. Как будто br ответвилась от мастера только что.
git rebase --abort  //отменить

git checkout master  
git merge --no-ff tekushaya
git rebase -i HEAD~2  +выбрать у всех pick =>сольет параллельную ветку в общий ствол, как будто мы делали merge без --no-ff 

Не перемещайте коммиты, уже отправленные в публичный репозиторий.

Те без опаски пользуйтесь git rebase смело до тех пор, пока Вы работаете в своей (удаленной?) ветке один. Как только к ветке присоединяется ваш коллега, подтягивайте изменения из основной ветки через merge. Это связано с тем, что rebase перезаписывает историю коммитов, и пушить на сервер вам придется с опцией --force.


КОНФЛИКТ в ходе REBASE:
git add/rm <conflicted_files>
git rebase --continue
пишем коментарий для консолидирующего коммита ребазируемой ветки, Ctrl+O, Enter, Ctrl+X, 
или просто (F2) //Close the current file buffer / Exit from nano
then решение конфликта со следующим конфликтным ребазируемым коммитом...
or
git rebase --abort


REBASE ТОЛЬКО 1, последнего КОММИТА
git rebase -i b2      //rebase на top ветки b2
pick 3680d75 added-cauldron  //его- захватим
drop 99de9ad added-shrine    //остальные коммиты ребазируемой ветки- отклоним. Далее они СТИРАЮТСЯ!
drop 1553a8d added-proof
Сохраняем файл и выходим из редактора. Для nano это  Ctrl+O, Enter, Ctrl+X.
Правим "конфликт в ходе REBASE" и продолжаем: git rebase --continue
=>> захваченный коммит стал веткой, отходящей от top'a b2.
head остается на ребазируемой ветке


ПОСЛЕДУЮЩИЙ push
git push —force
git push -f origin new_branch




=REBASE ветки ВНИЗ ПО ДЕРЕВУ 
= rebase ветки ВНИЗ ПО СТВОЛУ дерева, от которого отходит текущая ветка.
git rebase -i HEAD~4  //rebase ветку на 5-й коммит ОТ ТОП ВЕТКИ вниз по ветке и далее по родительскому стволу. Коммиты родительского ствола остаются СОХРАННЫМИ.
в none-редакторе поправим и сохраним:
pick a6096d9 added-1    //4-тый от топа, самый ранний коммит
squash abe6c6f added-2       //squash- сдавить
squash 1fd69c5 added-3
squash 7cd27df added-4  //самый свежий коммит
Ctrl+O, Enter, Ctrl+X   //[Esc]:wq[Enter] (wq - значит, write + quit) или [Esc]:q[Enter] для vim.
Нам предложат написать комментарий для объединённого коммита, напишем.
Ctrl+O, Enter, Ctrl+X
=> перемещение pick-коммитов из заявленных 4 комитов на 5-тый коммит с одновременным сжатием ветки до одного коммита (применили squash).

сжимаются коммиты ТОЛЬКО ТЕКУЩЕЙ ветки, родительский ствол остается целым! Но по родительскому стволу надо ставить squash!



= REBASE в форме СЖАТИЯ КОММИТОВ СВОЕЙ ВЕТКИ
git rebase -i HEAD~4  ,находясь на топе свей же ветки => сжимаем коммиты. 4-сколько коммитов, считая с верхушки, мы обрабатываем.
pick/squash/squash... (pick-самый ранний(самый старый, нижний) коммит, остальные-squash).

ctrl o
Enter
ctrl x


//CHERRY-PICK (клонирование коммита как новый коммит)
git cherry-pick 5589877          # скопировать на активную ветку изменения из указанного коммита, закоммитить эти изменения
git cherry-pick master~2..master # скопировать на активную ветку изменения из master (2 последних коммита)
git cherry-pick -n 5589877       # скопировать на активную ветку изменения из указанного коммита, но НЕ КОММИТИТЬ (подразумевается, что мы сами потом закоммитим)
git cherry-pick master..feature  # скопировать на активную ветку изменения из всех коммитов ветки feature с момента её расхождения с master (похоже на слияние веток, но это копирование изменений, а не слияние), закоммитить эти изменения; это может вызвать конфликт
git cherry-pick --abort    # прервать конфликтный перенос коммитов
git cherry-pick --continue # продолжить конфликтный перенос коммитов (сработает только после решения конфликта)




//HEAD_DETECHED  
-мы можем “потерять” отсоединенный коммит С5, если забудем его хэш.
git reflog  //история перемещения HEAD с указанием(!) хэшей коммитов и по линии отсоединенной головы
git st      //тоже укажет хэши коммитов по текущей detached_ HEAD ветке

как исправить:
мы находимся на detached_ HEAD ветке
git checkout master

git branch lost_commits 84b361c  //создаем от ветки master новую ветку lost_commits, 84b361c- "голова" detached_ HEAD ветки

git checkout lost_commits




=========
=====ФАЙЛ

//ГЕНЕРАЦИЯ ФАЙЛА
$ mkdir Desktop/my/     //Создаем папку
touch fileHere.vue         //Создаем файл
git rm -r folder_name   //Удаление папки
git rm HLAM.md          //Удаление файла
git rm -f HLAM.md       //принудительное удаление файла, если файл уже проиндексирован.
rm -rf name             //принудительное удаление файла кратко

git mv name_old name_new   //ПЕРЕИМЕНОВАНИЕ ФАЙЛА, расширение файла здесь тоже указываем

//ПРОСМОТР ФАЙЛА
git show branch-name:file-name.js     //посмотреть на какой-либо файл в другой ветке, не переключаясь на неё, коммит ветки- последний.
git show branch-name:filename.vue > fileHere.vue  ////сохранить файл из чужой ветки, коммит у ветки- последний.
git show 7c4eacc:./src/views/filename.vue > fileHere.vue  //Просто перенаправьте вывод git show в файл текущего коммита.

>>посмотреть на какой-либо файл
touch fileHere.vue
git show 0e040fbb:front/js/components/DataList.vue > fileHere.vue

git blame file.js   //Кто работал с файлом


//DIFF ФАЙЛА
git diff --color-words     //сравнить рабочую директорию и индекс
git diff file.js           //незакомеченные изменения данного файла и индекс
git diff HEAD           //сравнить рабочую директорию и коммит, на который указывает HEAD

git diff master current   //сравнить ветку current по сравнению с веткой master
git diff master...current   ##посмотреть что сделано в ветке current с момента расхождения с master


git diff 7c4eacc:file_name 6107c51d:file_name  //>>На первый накладывается 6107c51d, поэтому (-)-7c4eacc, (+)-6107c51d. 
git diff 7c4eacc:file_name 6107c51d:file_name > fileHere.vue //вывести не в консоле, а сохранить в 
git diff branch1name branch2name --- path/to/file  //
git diff ..someBranch path/to/file.js                // файл на текущей ветке с someBranch

git log -p -5 -- src/App.vue     ## История данного файла с DIFF-ами, цепочка №5 by enter-step, (q-выход).


//ОТКАТ ФАЙЛА
git checkout .                 //отменить во ВСЕХ файлах последние изменения
git checkout -- .              //отменить во ВСЕХ файлах последние изменения
git checkout a974c20c          //откатить ВСЕ файлы к указанному коммиту
git checkout App.vue           //(срабатывает) отмена в ДАННОМ файле незакоммеченных изменений (но мб уже сохраненных)
git checkout a974c20c src/App.vue   //откатить ДАННЫЙ файл к указанному коммиту


//ОТКАТ ФАЙЛА- отмена в файле закоммеченных изменений
git reset --soft HEAD~2 //отменяем 2 последние "git commit"
git commit

git reset --hard        //вернуть то, что в коммите, на который указывает HEAD




===============
========RESET
Мы осуществляем
-изменения в файле
-add (индексация)
-commit

=устраняем этап "commit"
git reset --soft HEAD~  //откатываем head до предыдущего add (устраняем этап "commit")

git reset --soft HEAD~2 //тоже, но передвинуть на 2 комита назад
git commit              //получается аналог git commit --amend

=устраняем этап "commit" и "add"
git reset               //убрать из индекса все добавленные в него изменения (в рабочей директории все изменения сохранятся), антипод git add
git reset HEAD~         //устраняем этап "commit" и "add" на 1 коммит назад, т.е. возвращаемся к состоянию "после предыдущего коммита + сохраняются  внесенные изменения".
git reset HEAD~1
git reset --mixed HEAD~   // --mixed можно не указывать, он по-умолчанию
git reset file
git reset HEAD file
git reset a974c20c file                //
git reset --mixed HEAD file            //устраняем индкасацию данного файла
далее повторно коммитем, но без исключенного из индекса файла file

=устраняем этап "commit", "add" и внесенные изменения в файле
git reset --hard         //устраняем все внесенные изменения
git reset --hard HEAD~   //устраняем этап "commit", "add" и внесенные изменения в файле
git reset --hard HEAD~1
git reset --hard @~      // ===передвинуть HEAD (и ветку) на предыдущий коммит, рабочую директорию и индекс сделать такими, какими они были в момент предыдущего коммита
git reset --hard 75e2d51 //передвинуть HEAD (и ветку) на коммит с указанным хешем, рабочую директорию и индекс сделать такими, какими они были в момент указанного коммита





=============== 
========ЗАНАЧКА
git stash save "done" -u //save- с комментарием,  -u - сохраняет и пока незарегистрированные файлы. Текущая рабочее состояние СБРАСЫВАЕТСЯ до HEAD’а, переключаться между ветками можно;
git stash list
git stash apply  //применяем последнюю заначку
git stash apply stash@{1}
git stash branch new_branch_name stash@{1}  //применить, создав новую ветку. Заначка удаляется.
git stash pop   //применение с удалением заначки
git stash show -p  //просмотр заначки

при конфликте apply здесь можно делать "add .", a коммитить изменения сразу нет необходимости, как после git merge конфликтов;

git stash drop stash@{1}  //удалить заначку
git stash clear           //удалить все заначки


================
===








